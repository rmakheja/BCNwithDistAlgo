import sys
import nacl
from nacl.public import PrivateKey, Box
import logging
import pickle
import nacl
import nacl.encoding
import nacl.hash
import nacl.signing

class Replica(process):
    def setup(olympus: Olympus, list_clients: list, list_replicas: list, config: set):
        output("Setting up the Replica...")
        self.logger = logging.getLogger(__name__)
        self.history = {}
        self.cache = {}
        self.slot_no = 0
        self.core_data = {}
        self.terminate = False
        self.isImmutable = False
        self.privateKey = "Default"
        self.client_public_keys = {}
        self.publicKey = "Default"
        self.replica_public_keys = {}
        self.replica_verify_keys = {}
        self.signingKey = "Default"
        self.m_client_req = [-1]*config['num_clients']
        self.m_fwd_req = [-1]*config['num_clients']
        self.m_shuttle = [-1]*config['num_clients']
        self.m_r_shuttle = [-1]*config['num_clients']
        self.ch_oper = [False]*config['num_clients']
        self.ch_res = [False]*config['num_clients']
        self.drop_res = [False]*config['num_clients']
        self.failures = extract_failures()
        self.HASHER = nacl.hash.sha256
        self.replica_verify_keys = {}
        self.timer = config['nonhead_timeout']
        if(self == list_replicas[0]):
            timer = config['head_timeout']


    def receive(msg=('keys', payload), from_= sender):
        print('Received all KEYS from the Olympus ---')
        self.privateKey = payload['private_key']
        self.publicKey = payload['public_key']
        self.signingKey = payload['signing_key']
        self.replica_public_keys = payload['replica_public_keys']
        self.client_public_keys = payload['client_public_keys']
        self.replica_verify_keys = payload['replica_verify_keys']

    def receive(msg=('result_shuttle', encrypted_payload, replica_index), from_= sender):
        output("Received the Result shuttle...")
        decrypt_box = Box(self.privateKey, self.replica_public_keys[str(sender)])
        plaintext = decrypt_box.decrypt(encrypted_payload)
        payload = pickle.loads(plaintext)
        ind = int(replica_index)
        output('Received the result shuttle')
        client_id = list_clients.index(payload['client'])
        check_failures('result_shuttle', client_id)

        if ch_res[client_id]:
            binary_result = pickle.dumps('OK')
            result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
            payload['result_proof'][ind][3] = result_hash
            ch_res[client_id] = False
        if drop_res[client_id] :
            print('dropping..',len(payload['result_proof']))
            payload['result_proof'].pop(0)
            print('dropped..',len(payload['result_proof']))
            drop_res[client_id] = False
        cache[str(payload['client']) + ' : ' + str(payload['seqNo']) ] = payload
        ind -= 1
        if(ind >= 0):
            encrypted_result_shuttle = getEncryptedMsg(payload, replica_public_keys[str(list_replicas[ind])])
            send(('result_shuttle', encrypted_result_shuttle, str(ind)), to= list_replicas[ind])
            #send(('result_shuttle', payload, str(ind)), to= list_replicas[ind])

    def receive(msg=('execute', encrypted_payload, replica_index), from_= sender):

        output('Received normal task execution from ' + str(sender))
        #payload = encrypted_payload ## THIS IS USED FOR TEST_EXECUTE (TESTING ENCRYPTION)
        payload = {}
        if(str(sender) in client_public_keys):
            decrypt_box = Box(self.privateKey, client_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_payload)
            payload = pickle.loads(plaintext)
        else:
            decrypt_box = Box(self.privateKey, replica_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_payload)
            payload = pickle.loads(plaintext)

        ind = int(replica_index) + 1
        client_id = list_clients.index(payload['client'])
        if(ind == 1):
            ## HEAD case
            print('HEAD received the execution request...')

            ## Verify if this slot is not already occupied and its previous is occupied.
            if(self.slot_no not in history and ( self.slot_no == 0 or (self.slot_no - 1) in history)):
                output('Slot verification success...!')
                result = execute_actual_command(payload['oper'])
                #print("Execution Result at HEAD is - " + result)
                order_shuttle = payload
                order_shuttle['type'] = "Order Shuttle"
                order_shuttle['slot_no'] = self.slot_no
                order_shuttle['result'] = result
                order_proof = []
                result_proof = []
                #print('Creating order stmt...')
                order_stmt = [self.slot_no, payload['client'], payload['seqNo'], payload['oper']]

                if sender != self:
                    check_failures('client_request', client_id)

                if self.ch_oper[client_id] :
                    order_stmt[3] = "get('x')"
                    self.ch_oper[client_id] = False

                output('Added order statement to the history and forwarded the shuttle ahead')
                order_shuttle = process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result)
                history[order_shuttle['slot_no']] = order_stmt

                encrypted_msg = getEncryptedMsg(order_shuttle, replica_public_keys[str(list_replicas[ind])])

                send(('execute', encrypted_msg, str(ind)), to= list_replicas[ind])
                # send(('execute', order_shuttle, str(ind)), to= list_replicas[ind])
                self.slot_no +=1
            else:
                output('invalid slot_no... or waiting for previous slot')
        elif(ind == (len(list_replicas))):
            #print('In TAIL')
            ## TAIL case
            print('TAIL received the execution request...')

            result = ""
            order_shuttle = payload
            order_stmt = [payload['slot_no'],  payload['client'], payload['seqNo'], payload['oper']];
            if(validate_order_proof(order_shuttle["order_proof"], order_stmt)):
                result = execute_actual_command(order_shuttle['oper'])
                print("Execution Result at TAIL is - " + result)
                order_proof = order_shuttle['order_proof']
                result_proof = order_shuttle['result_proof']

                if not validate_result_proof(result_proof, result, order_shuttle['oper']):
                    output('invalid result_proof')
                    ## Reconfig request from replica
                else :
                    check_failures('shuttle', client_id)

                    if self.ch_oper[client_id] :
                        order_stmt[3] = "get('x')"
                        self.ch_oper[client_id] = False
                    order_shuttle = process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result)
                    history[order_shuttle['slot_no']] = order_stmt

                    clientResult = {}
                    clientResult['seqNo'] = order_shuttle['seqNo']
                    clientResult['client'] = order_shuttle['client']
                    clientResult['oper'] = order_shuttle['oper']
                    clientResult['result'] = result
                    clientResult['result_proof'] = order_shuttle['result_proof']

                    if ch_res[client_id]:
                        binary_result = pickle.dumps('OK')
                        result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
                        clientResult['result_proof'][ind][3] = result_hash
                        ch_res[client_id] = False
                    if drop_res[client_id] :
                        clientResult['result_proof'].pop(0)
                        drop_res[client_id] = False

                    cache[str(order_shuttle['client']) + ' : ' + str(order_shuttle['seqNo'])] = clientResult

                    output('Added order statement to the history; added shuttle to cache and forwarded the shuttle to client with result...')

                    ## Send Result to client
                    encrypted_msg = getEncryptedMsg(clientResult, client_public_keys[str(payload['client'])])
                    send(('result_message', encrypted_msg), to= payload['client'])
                    #send(('result_message', clientResult), to= payload['client'])

                    ## ind is already beyond last replica index. So subtract 2
                    ind = ind - 2
                    encrypted_result_shuttle = getEncryptedMsg(clientResult, self.replica_public_keys[str(list_replicas[ind])])
                    send(('result_shuttle', encrypted_result_shuttle, str(ind)), to= list_replicas[ind])


            else:
                output('Some error in order proof validation. Reconfigure the system...')
                ## Reconfig request from replica

        else:
            ## REST of the cases
            #print('In MIDDLE')
            print('MIDDLE replicas received the execution request...')

            order_shuttle = payload
            order_stmt = [payload['slot_no'], payload['client'], payload['seqNo'], payload['oper']];
            if(validate_order_proof(order_shuttle["order_proof"], order_stmt)):
                result = execute_actual_command(order_shuttle['oper'])
                print("Execution Result is - " + result)
                order_proof = order_shuttle['order_proof']
                result_proof = order_shuttle['result_proof']
                check_failures('forward_request', client_id)
                if not validate_result_proof(result_proof, result, order_shuttle['oper']):
                    output('invalid result_proof')
                    ## Reconfig request from replica
                else :
                    if self.ch_oper[client_id] :
                        order_stmt[3] = "get('x')"
                        self.ch_oper[client_id] = False
                    order_shuttle = process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result)
                    history[order_shuttle['slot_no']] = order_stmt
                    output('Added order statement to the history and forwarded the shuttle ahead...')

                    encrypted_msg = getEncryptedMsg(order_shuttle, replica_public_keys[str(list_replicas[ind])])
                    send(('execute', encrypted_msg, str(ind)), to= list_replicas[ind])

                    #send(('execute', order_shuttle, str(ind)), to= list_replicas[ind])
            else:
                output('Some error in order proof validation. Reconfigure the system...')
                ## Reconfig request from replica

    def process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result):

        output('Adding order-statement, result statement and there signatures to shuttle')
        binary_order_stmt = pickle.dumps(order_stmt)
        signed_order_stmt = self.signingKey.sign(binary_order_stmt)

        binary_result = pickle.dumps(result)
        result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
        order_proof.append([order_stmt, signed_order_stmt])
        order_shuttle['order_proof'] = order_proof

        output('Adding result statement and its signature to shuttle')
        result_stmt = [order_stmt[1], order_stmt[2], order_stmt[3], result_hash]
        binary_result_stmt = pickle.dumps(result_stmt)
        signed_result_stmt = self.signingKey.sign(binary_result_stmt)

        ##result_proof.append((order_shuttle['client'], order_shuttle['seqNo'], order_shuttle['oper'], result_hash))
        result_proof.append([result_stmt, signed_result_stmt])
        order_shuttle['result_proof'] = result_proof
        return order_shuttle

    def validate_order_proof(order_proof, order_stmt):
        output('Validating the order proof ...')
        # first check if the signature of order proofs are matching

        # check if received slot no is not in history and the previous slot is finished
        slot_no = int(order_stmt[0])
        if(slot_no in history):
            return False

        binary_order_stmt = pickle.dumps(order_stmt)
        signed_order_stmt = self.signingKey.sign(binary_order_stmt)
        for i in range(0, len(order_proof)):
            curr_signed_order_p = order_proof[i][1]
            try:
                self.replica_verify_keys[str(list_replicas[i])].verify(curr_signed_order_p)
            except nacl.exceptions.BadSignatureError:
                output("Signature verification failed for order statement.")
                return False

        for each_order_p in order_proof:
            if(each_order_p[0] != order_stmt):
                output("Order statement mismatch.")
                return False;

        output('Validation of order proof success...')
        return True

    def validate_result_proof(result_proof, result, operation):
        output('Validating result proof...')
        binary_result = pickle.dumps(result)
        cur_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
        for i in range(0, len(result_proof)):
            curr_signed_result_p = result_proof[i][1]
            try:
                self.replica_verify_keys[str(list_replicas[i])].verify(curr_signed_result_p)
            except nacl.exceptions.BadSignatureError:
                output("Signature verification failed for result statement.")
                return False

        for res_stmt in result_proof:
            if((res_stmt[0][3] != cur_hash) or (res_stmt[0][2] != operation)):
                output('Result statement verification failed...!!')
                return False
        output('Validation of result proof success...')
        return True

    def execute_actual_command(operation):
        output('Executing actual operation command ...' + operation)
        result = ""
        ## execute operation on current state
        splits = operation.split("'")
        if(operation[0] == 'p'):
            ind = operation.index(',')
            ind1 = len(operation) - 1
            key = operation[4:ind].strip('\'').strip()
            val = operation[ind+1 : ind1].strip('\'')
            print(key, ' => ', val)
            core_data[key] = val
            result = "OK"
        elif(operation[0] == 'g'):
            ind = operation.index('(')+1
            ind1 = len(operation) - 1
            key = operation[ind: ind1].strip('\'').strip()
            print(key)
            if(key in core_data):
                result = core_data[key]
            else:
                result = ""
        elif(operation[0] == 'a'):
            ind = operation.index(',')
            ind1 = len(operation) - 1
            key = operation[8:ind].strip('\'').strip()
            val = operation[ind+1 : ind1].strip('\'')
            if(key in core_data):
                core_data[key] = str(core_data[key]) + str(val)
                result = "OK"
            else:
                result = "fail"
            print(key, ' => ', val)
        elif(operation[0] == 's'):
            ind = operation.index(',')
            ind1 = len(operation) - 2
            key = operation[6:ind].strip('\'').strip()
            ran = operation[ind+2 : ind1]
            start_end = ran.split(':')
            print(key, ' => ', start_end)
            if(key in core_data and (int(start_end[0]) >= 0) and (int(start_end[1]) <= len(core_data[key]))):
                core_data[key] = core_data[key][int(start_end[0]):int(start_end[1])]
                result = "OK"
            else:
                result = "Fail"
        else:
            result = "fail"
        output("Operation execution Success...")
        return result

    def receive(msg=('retrans', encrypted_command, replica_index), from_= sender):
        ind = int(replica_index)
        command = {}
        if(str(sender) in client_public_keys):
            decrypt_box = Box(self.privateKey, client_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_command)
            command = pickle.loads(plaintext)
        else:
            decrypt_box = Box(self.privateKey, replica_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_command)
            command = pickle.loads(plaintext)

        output('Received retransmission...')
        cache_key = str(command['client']) + ' : ' + str(command['seqNo'])
        client_id = list_clients.index(command['client'])
        if sender == command['client']:
            check_failures('client_request', client_id)
        else :
            check_failures('forward_request', client_id)
        if(cache_key in cache):
            clientResult = cache[cache_key]
            if ch_res[client_id]:
                binary_result = pickle.dumps('OK')
                result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
                clientResult['result_proof'][ind][3] = result_hash;
                ch_res[client_id] = False
            if drop_res[client_id]:
                clientResult['result_proof'].pop(0)
                drop_res[client_id] = False

            encrypted_cache = getEncryptedMsg(clientResult, self.client_public_keys[str(command['client'])])
            send(('retrans_res', encrypted_cache), to= command['client'])
            #send(('retrans_res', cache[cache_key]), to= command['client'])

        elif(self.isImmutable):
            send(('Error - Replica Immutable'), to= command['client'])
        else:
            ind += 1
            if(ind == 1):
                ## HEAD
                #check if oper in history
                foundSlot = False
                for slot in history:
                    stmt = history[slot]
                    if(stmt[1] == command['client'] and stmt[2] == command['seqNo']):
                        foundSlot = True
                if not foundSlot:
                    encrypted_command = getEncryptedMsg(command, self.replica_public_keys[str(self.list_replicas[0])])
                    send(('execute', encrypted_command, '0'), to= self.list_replicas[0])
                    #send(('execute', command, '0'), to= self.list_replicas[0])
                ## Start the replica timer for retranmission
            else:
                ## send retrans to head and wait for result.
                encrypted_command = getEncryptedMsg(command, self.replica_public_keys[str(self.list_replicas[0])])
                send(('retrans', encrypted_command, '0'), to= self.list_replicas[0])
                #send(('retrans', command, '0'), to= self.list_replicas[0])

            if await(cache_key in cache):
                clientResult = cache[cache_key]
                if ch_res[client_id]:
                    binary_result = pickle.dumps('OK')
                    result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
                    clientResult['result_proof'][ind][3] = result_hash;
                    ch_res[client_id] = False
                if drop_res[client_id] :
                    clientResult['result_proof'].pop(0)
                    drop_res[client_id] = False

                    encrypted_cache = getEncryptedMsg(clientResult, self.client_public_keys[str(command['client'])])
                    send(('retrans_res', encrypted_cache), to= command['client'])
                    #send(('retrans_res', cache[cache_key]), to= command['client'])
            elif timeout(self.timer):
                    output('retrans failed, replica dint receive result shuttle')
                    ##send reconfig

    def getEncryptedMsg(msg, receiverPubKey):
        box = Box(self.privateKey, receiverPubKey)
        binary_msg = pickle.dumps(msg)
        encrypted_msg = box.encrypt(binary_msg)
        return encrypted_msg

    def dict_to_binary(the_dict):
        binary = pickle.dumps(the_dict)
        return binary

    def binary_to_dict(the_binary):
        d = pickle.loads(the_binary)
        return d

    def run():
        output('Started Replica...waiting for an operations...')
        await(terminate)

    def check_failures(type, client_id):
        if type == 'client_request':
            self.m_client_req[client_id] += 1
            failure_key =  'client_request(' + str(client_id) + ',' + str(self.m_client_req[client_id]) + ')'
        elif type == 'result_shuttle':
            self.m_r_shuttle[client_id] += 1
            failure_key =  type + '(' + str(client_id) + ',' + str(self.m_r_shuttle[client_id]) + ')'
        elif type == 'forward_request':
            self.m_fwd_req[client_id] += 1
            failure_key =  type + '(' + str(client_id) + ',' + str(self.m_fwd_req[client_id]) + ')'
        elif type == 'shuttle':
            self.m_shuttle[client_id] += 1
            failure_key =  type + '(' + str(client_id) + ',' + str(self.m_shuttle[client_id]) + ')'

        if failure_key in failures :
            failure = failures[failure_key]
            if failure == 'change_operation()':
                self.ch_oper[client_id] = True
            elif failure == 'change_result()':
                self.ch_res[client_id] = True
            elif failure == 'drop_result_stmt()':
                self.drop_res[client_id] = True

    def extract_failures() :
        failures = {}
        key = 'failures[0,' + str(list_replicas.index(self)) + ']'
        if key in config:
            str_fail = config[key]
            splits = str_fail.split(';')
            for trig_fail in splits:
                trig_fail = trig_fail.strip()
                ind = trig_fail.index(')') + 1
                failures[trig_fail[0:ind]] = trig_fail[ind+1 : len(trig_fail)].split()[0]
        print(failures)
        return failures

