import sys
import nacl
from nacl.public import PrivateKey, Box
import logging
import pickle
import nacl
import nacl.encoding
import nacl.hash
import nacl.signing

class Replica(process):
    def setup(olympus: Olympus, list_clients: list, list_replicas: list, config: set, currConfigSeqNo: int):
        output("R: [Setup] Replica " + getSelfId() + " : " + str(self))
        self.logger = logging.getLogger(__name__)
        self.history = {}
        self.cache = {}
        self.slot_no = 0
        self.core_data = {}
        self.terminate = False
        self.isImmutable = False
        self.privateKey = "Default"
        self.client_public_keys = {}
        self.publicKey = "Default"
        self.replica_public_keys = {}
        self.replica_verify_keys = {}
        self.signingKey = "Default"
        self.oly_public_key = "Default"
        self.olympus_verify_key = "Default"
        self.m_client_req = [-1]*config['num_clients']
        self.m_fwd_req = [-1]*config['num_clients']
        self.m_shuttle = [-1]*config['num_clients']
        self.m_r_shuttle = [-1]*config['num_clients']
        self.m_wedge_request = -1
        self.m_new_conf = -1
        self.m_chkpnt = -1
        self.m_chkpnt_completed = -1
        self.m_running_state = -1
        self.m_catch_up = -1
        self.ch_oper = [False]*config['num_clients']
        self.ch_res = [False]*config['num_clients']
        self.drop_res = [False]*config['num_clients']
        self.trunc = 0
        self.drop = False
        self.invalidOrderSig = False
        self.invalidResultSig = False
        self.drop_chkpnts = False
        self.failures = extract_failures()
        self.HASHER = nacl.hash.sha256
        self.replica_verify_keys = {}
        self.timer = config['nonhead_timeout']
        if(self == list_replicas[0]):
            timer = config['head_timeout']
        self.checkpoint_len = 5
        self.checkpoints = []
        self.checkpoint_complete = True


    def receive(msg=('keys', payload), from_= sender):
        output('R: [keys] F: ' + getSenderId(sender) + ' T: Replica ' + getSelfId())
        self.privateKey = payload['private_key']
        self.publicKey = payload['public_key']
        self.signingKey = payload['signing_key']
        self.replica_public_keys = payload['replica_public_keys']
        self.client_public_keys = payload['client_public_keys']
        self.replica_verify_keys = payload['replica_verify_keys']
        self.oly_public_key = payload['oly_public_key']
        self.olympus_verify_key = payload['olympus_verify_key']

    def receive(msg=('abort', signed_abort), from_= sender):
        output('R: [abort] F: ' + getSenderId(sender) + ' T: Replica ' + getSelfId())
        try:
            self.olympus_verify_key.verify(signed_abort)
            self.terminate = True
        except:
            output('I: Signature verification failed for ABORT request at Replica ' + getSelfId())

    def receive(msg=('wedge', signed_wedge), from_= sender):
        output('R: [wedge] F: ' + getSenderId(sender) + ' T: Replica ' + getSelfId())
        check_failures('wedge', -1)

        try:
            self.olympus_verify_key.verify(signed_wedge)
            self.isImmutable = True
            wedged_response = {}
            wedged_response['History'] = self.history

            output('S: [wedged] F: Replica ' + getSelfId() + ' T: ' + str(olympus) + 'I: history len - ' + str(len(self.history)))

            encrypted_msg = getEncryptedMsg(wedged_response, self.oly_public_key)
            send(('wedged', encrypted_msg), to= olympus)
        except nacl.exceptions.BadSignatureError:
            output('I: Signature verification failed for WEDGE request at Replica ' + getSelfId())

    def receive(msg=('result_shuttle', encrypted_payload, replica_index), from_= sender):
        payload = decrypt(encrypted_payload, sender)
        ind = int(replica_index)
        client_id = list_clients.index(payload['client'])
        output('R: [result_shuttle] F: ' + getSenderId(sender) + ' T: Replica ' + getSelfId() + 'I: client Id - '+ str(client_id) + ' seqNo - '+ str(payload['seqNo']) +' oper-' + payload['oper'])

        check_failures('result_shuttle', client_id)
        injectFailure(client_id, payload, 'sendRes', ind)

        cache[str(payload['client']) + ' : ' + str(payload['seqNo'])] = payload
        ind -= 1
        if(ind >= 0):
            encrypted_result_shuttle = getEncryptedMsg(payload, replica_public_keys[str(list_replicas[ind])])

            output('S: [result_shuttle] F: Replica ' + getSelfId() + ' T: Replica' + str(ind) + ' I: client Id - '+ str(client_id) + ' seqNo - '+ str(payload['seqNo']) +' oper-' + payload['oper'])

            send(('result_shuttle', encrypted_result_shuttle, str(ind)), to= list_replicas[ind])

    def receive(msg=('execute', encrypted_payload, replica_index), from_= sender):

        if(self.isImmutable):
            output('R: [execute] F: ' + getSenderId(sender) + ' T : Replica ' + getSelfId() + 'I: ReplicaImmutable')
            output('S: [Error - Replica Immutable] F: Replica '+ getSelfId() + ' T: ' + getSenderId(sender) + ' I: execute request')
            send(('Error - Replica Immutable'), to= sender)
        else:
            order_shuttle = decrypt(encrypted_payload, sender)

            ind = int(replica_index) + 1
            client_id = list_clients.index(order_shuttle['client'])
            output('R: [execute] F: ' + getSenderId(sender) + ' T: Replica ' + getSelfId() + ' I: client Id - '+ str(client_id) + ' seqNo - '+ str(order_shuttle['seqNo']) +' oper-' + order_shuttle['oper'])
            if sender != self:
                if ind == 1:
                    check_failures('client_request', client_id)
                else:
                    check_failures('shuttle', client_id)

            result = execute_actual_command(order_shuttle['oper'])

            if(ind == 1):
                if(self.slot_no not in history and (self.slot_no == 0 or (self.slot_no - 1) in history)):
                    order_shuttle['type'] = "Order Shuttle"
                    order_shuttle['slot_no'] = self.slot_no
                    order_shuttle['result'] = result

                    output('I: Head assigned slot : ' + str(self.slot_no) + ' for : client Id - ' + str(client_id) + ' seqNo - '+ str(order_shuttle['seqNo']) +' oper -' + order_shuttle['oper'])

                    self.slot_no +=1

                else :
                    output('I: invalid slot_no... or waiting for previous slot at head')

            order_stmt = [order_shuttle['slot_no'],  order_shuttle['client'], order_shuttle['seqNo'], order_shuttle['oper']];
            order_proof = {} if ind == 1 else order_shuttle['order_proof']
            result_proof =  {} if ind == 1 else order_shuttle['result_proof']


            if ind == 1 or (validate_order_proof(order_shuttle["order_proof"], order_stmt) and validate_result_proof(result_proof, result, order_shuttle['oper'])):
                injectFailure(client_id, order_stmt, 'recOper', ind)

                order_shuttle = process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result)
                self.history[order_shuttle['slot_no']] = order_stmt
                forwardOrderShuttle(order_shuttle, ind)
                hist_len = len(self.history)
                if(ind == 1 and hist_len != 1 and (hist_len % self.checkpoint_len) == 1):
                    await(self.checkpoint_complete)
                    self.checkpoint_complete = False
                    sendCheckpoint(1, [], hist_len - 1)
            else:
                output('S: [recofig] F: Replica ' + getSelfId() + ' T: olympus I: Error in order proof or result proof validation')
                sendReconfigReq()


    def process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result):
        output('I: adding order stmt : ' + str(order_stmt) + ' at Replica ' + getSelfId())
        binary_order_stmt = pickle.dumps(order_stmt)
        signed_order_stmt = self.signingKey.sign(binary_order_stmt)

        binary_result = pickle.dumps(result)
        result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
        order_proof[str(self)] = ([order_stmt, signed_order_stmt])
        order_shuttle['order_proof'] = order_proof


        result_stmt = [order_stmt[1], order_stmt[2], order_stmt[3], result_hash]
        binary_result_stmt = pickle.dumps(result_stmt)
        signed_result_stmt = self.signingKey.sign(binary_result_stmt)

        output('I: adding result stmt : ' + str(result_stmt) + ' at Replica ' + getSelfId())

        result_proof[str(self)] = ([result_stmt, signed_result_stmt])
        order_shuttle['result_proof'] = result_proof
        return order_shuttle

    def validate_order_proof(order_proof, order_stmt):

        slot_no = int(order_stmt[0])
        if(slot_no in self.history):
            output('E: [FAIL] [Order Proof Validation] [Replica ' + getSelfId() +']- Slot pre-occupied for operation: ' + order_stmt[3] + ' slot_no: ' + str(order_stmt[0]) + ' seqNo: ' + str(order_stmt[2]))
            return False

        binary_order_stmt = pickle.dumps(order_stmt)
        signed_order_stmt = self.signingKey.sign(binary_order_stmt)
        for replicaName, each_order_p in order_proof.items():
            curr_signed_order_p = each_order_p[1]
            try:
                self.replica_verify_keys[replicaName].verify(curr_signed_order_p)
            except nacl.exceptions.BadSignatureError:
                output('E: [FAIL] [Order Proof Validation] [Replica ' + getSelfId() +'] - Signature verification failed for operation: ' + order_stmt[3] + ' slot_no: ' + str(order_stmt[0]) + ' seqNo: ' + str(order_stmt[2]))
                return False

        for replicaName, each_order_p in order_proof.items():
            if(each_order_p[0] != order_stmt):
                output('E: [FAIL] [Order Proof Validation] [Replica ' + getSelfId() +'] - Order statement mismatch for operation: ' + order_stmt[3] + ' slot_no: ' + str(order_stmt[0]) + ' seqNo: ' + str(order_stmt[2]))
                return False;

        output('I: [SUCCESS] [Order Proof Validation] [Replica ' + getSelfId() +'] - operation: ' + order_stmt[3] + ' slot_no: ' + str(order_stmt[0]) + ' seqNo: ' + str(order_stmt[2]))
        return True

    def validate_result_proof(result_proof, result, operation):

        binary_result = pickle.dumps(result)
        cur_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
        for replicaName, result_proof_i in result_proof.items():
            curr_signed_result_p = result_proof_i[1]
            try:
                self.replica_verify_keys[replicaName].verify(curr_signed_result_p)
            except nacl.exceptions.BadSignatureError:
                output('E: [FAIL] [Result Proof Validation] [Replica ' + getSelfId() +'] - Signature verification failed for operation: ' + operation )
                return False

        for replicaName, res_stmt in result_proof.items():
            if(res_stmt[0][3] != cur_hash):
                output('E: [FAIL] [Result Proof Validation] [Replica ' + getSelfId() +'] - result hash mismatch for operation: ' + operation)
                return False
            elif (res_stmt[0][2] != operation):
                output('E: [FAIL] [Result Proof Validation] [Replica ' + getSelfId() +'] - operation mismatch for operation: ' + operation + ' received operation : '+ res_stmt[0][2])
                return False
        output('I: [SUCCESS] [Result Proof Validation] [Replica ' + getSelfId() +'] - for operation: ' + operation )
        return True

    def execute_actual_command(operation):
        output('I: [Execute Command] [Replica ' + getSelfId() +'] - command : ' + operation )
        result = ""

        splits = operation.split("'")
        if(operation[0] == 'p'):
            ind = operation.index(',')
            ind1 = len(operation) - 1
            key = operation[4:ind].strip('\'').strip()
            val = operation[ind+1 : ind1].strip('\'')

            core_data[key] = val
            result = "OK"

        elif(operation[0] == 'g'):
            ind = operation.index('(')+1
            ind1 = len(operation) - 1
            key = operation[ind: ind1].strip('\'').strip()
            if(key in core_data):
                result = core_data[key]
            else:
                result = ""

        elif(operation[0] == 'a'):
            ind = operation.index(',')
            ind1 = len(operation) - 1
            key = operation[8:ind].strip('\'').strip()
            val = operation[ind+1 : ind1].strip('\'')
            if(key in core_data):
                core_data[key] = str(core_data[key]) + str(val)
                result = "OK"
            else:
                result = "fail"

        elif(operation[0] == 's'):
            ind = operation.index(',')
            ind1 = len(operation) - 2
            key = operation[6:ind].strip('\'').strip()
            ran = operation[ind+2 : ind1]
            start_end = ran.split(':')

            if(key in core_data and (int(start_end[0]) >= 0) and (int(start_end[1]) <= len(core_data[key]))):
                core_data[key] = core_data[key][int(start_end[0]):int(start_end[1])]
                result = "OK"
            else:
                result = "Fail"

        else:
            result = "fail"
        output('I: [SUCCESS] [Execute Command] [Replica ' + getSelfId() +'] - command: ' + operation + ' result : '+ result)
        return result

    def receive(msg=('retrans', encrypted_command, replica_index), from_= sender):
        ind = int(replica_index)
        command = decrypt(encrypted_command, sender)
        client_id = list_clients.index(command['client'])

        output('R: [retrans] F: ' + getSenderId(sender) + 'T: Replica ' + getSelfId() + 'I: client Id - '+ str(client_id) + ' seqNo - '+ str(command['seqNo']) +' oper-' + command['oper'])

        if sender == command['client']:
            check_failures('client_request', client_id)
        else :
            check_failures('forward_request', client_id)

        cache_key = str(command['client']) + ' : ' + str(command['seqNo'])

        if(cache_key in cache):
            clientResult = cache[cache_key]
            injectFailure(client_id, clientResult, 'sendRes', ind)

            encrypted_cache = getEncryptedMsg(clientResult, self.client_public_keys[str(command['client'])])

            output('S: [retrans_res] [cache hit] F: Replica ' + getSelfId() + ' T: Client ' + str(client_id) + ' I: client Id - '+ str(client_id) + ' seqNo - '+ str(command['seqNo']) +' oper-' + command['oper'])

            send(('retrans_res', encrypted_cache), to= command['client'])

        elif(self.isImmutable):
            output('S: [Error - Replica Immutable] F: Replica '+ getSelfId() + ' T: Client ' + str(client_id) + 'I: Retrans req, Client ' + str(client_id) + ' seqNo - '+ str(command['seqNo']) +' oper-' + command['oper'])
            send(('Error - Replica Immutable'), to= command['client'])
        else:
            ind += 1
            if(ind == 1):
                foundSlot = False
                for slot in self.history:
                    stmt = self.history[slot]
                    if(stmt[1] == command['client'] and stmt[2] == command['seqNo']):
                        foundSlot = True
                if not foundSlot:
                    output('S: [execute] F: Replica '+ getSelfId() + ' T: Head I: Retrans req, Client ' + str(client_id) + ' seqNo - '+ str(command['seqNo']) +' oper -' + command['oper'])

                    encrypted_command = getEncryptedMsg(command, self.replica_public_keys[str(self.list_replicas[0])])
                    send(('execute', encrypted_command, '0'), to= self.list_replicas[0])
            else:
                output('S: [retrans] F: Replica '+ getSelfId() + ' T: Head I: Retrans req, Client ' + str(client_id) + ' seqNo - '+ str(command['seqNo']) +' oper -' + command['oper'])
                encrypted_command = getEncryptedMsg(command, self.replica_public_keys[str(self.list_replicas[0])])
                send(('retrans', encrypted_command, '0'), to= self.list_replicas[0])

            if await(cache_key in cache):
                clientResult = cache[cache_key]
                injectFailure(client_id, clientResult, 'sendRes', ind)
                encrypted_cache = getEncryptedMsg(clientResult, self.client_public_keys[str(command['client'])])

                output('S: [retrans_res] [received shuttle] F: Replica ' + getSelfId() + ' T: Client ' + str(client_id) + ' I: client Id - '+ str(client_id) + ' seqNo - '+ str(command['seqNo']) +' oper-' + command['oper'])

                send(('retrans_res', encrypted_cache), to= command['client'])
            elif timeout(self.timer):
                    output('S: [recofig] F: Replica ' + getSelfId() + ' T: olympus I: [timer expired] Retransmission Failed for client Id - '+ str(client_id) + ' seqNo - '+ str(command['seqNo']) +' oper-' + command['oper'])
                    sendReconfigReq()

    def check_failures(type, client_id):
        failure_key = ''
        if type == 'client_request':
            self.m_client_req[client_id] += 1
            failure_key =  'client_request(' + str(client_id) + ',' + str(self.m_client_req[client_id]) + ')'
        elif type == 'result_shuttle':
            self.m_r_shuttle[client_id] += 1
            failure_key = 'result_shuttle(' + str(client_id) + ',' + str(self.m_r_shuttle[client_id]) + ')'
        elif type == 'forward_request':
            self.m_fwd_req[client_id] += 1
            failure_key = 'forward_request(' + str(client_id) + ',' + str(self.m_fwd_req[client_id]) + ')'
        elif type == 'shuttle':
            self.m_shuttle[client_id] += 1
            failure_key =  'shuttle(' + str(client_id) + ',' + str(self.m_shuttle[client_id]) + ')'
        elif type == 'wedge':
            self.m_wedge_request += 1
            failure_key = 'wedge_request(' + str(self.m_wedge_request) + ')'
        elif type == 'new_config':
            self.m_new_conf += 1
            failure_key = 'new_configuration(' + str(self.m_new_conf) + ')'
        elif type == 'chkpnt':
            self.m_chkpnt += 1
            failure_key = 'checkpoint(' + str(self.m_chkpnt) + ')'
        elif type == 'chkpnt_completed':
            self.m_chkpnt_completed += 1
            failure_key = 'completed_checkpoint(' + str(self.m_chkpnt_completed) + ')'
        elif type == 'get_running_state':
            self.m_running_state += 1
            failure_key = 'get_running_state(' + str(self.m_running_state) + ')'
        elif type == 'catch_up':
            self.m_catch_up += 1
            failure_key = 'catch_up(' + str(self.m_catch_up) + ')'

        if failure_key in self.failures :
            output('I: [failure Trigger] [Replica ' +getSelfId() + '] trigger : ' + failure_key + 'failure ' + str(self.failures[failure_key]))
            for failure in self.failures[failure_key]:
                if failure == 'change_operation()':
                    self.ch_oper[client_id] = True
                elif failure == 'change_result()':
                    self.ch_res[client_id] = True
                elif failure == 'drop_result_stmt()':
                    self.drop_res[client_id] = True
                elif failure == 'truncate_history()':
                    self.trunc = int(failure[17:-1])
                elif failure.startsWith('sleep('):
                    t = int(failure[6:-1])
                    sleep(t/1000)
                elif failure == 'drop()':
                    self.drop = True
                elif failure == 'increment_slot()':
                    if(self == self.list_replicas[0]):
                        self.slot_no += 1
                elif failure == 'extra_op()' :
                    execute_actual_command('put('a','a')')
                elif failure == 'invalid_order_sig()':
                    self.invalidOrderSig = True
                elif failure == 'invalid_result_sig()':
                    self.invalidResultSig = True
                elif failure == 'drop_checkpt_stmts()':
                    self.drop_chkpnts = True
                elif failure == 'crash':
                    os._exit(-1)
    def extract_failures() :

        t_failures = {}
        key = 'failures[' + str(self.currConfigSeqNo) + ',' + str(list_replicas.index(self)) + ']'
        if key in config:
            str_fail = config[key]
            splits = str_fail.split(';')
            for trig_fail in splits:
                trig_fail = trig_fail.strip()
                ind = trig_fail.index(')') + 1
                key = trig_fail[0:ind]
                trig_key = trig_fail[0:ind]
                val = trig_fail[ind+1 : len(trig_fail)].split()[0]

                if trig_key in t_failures:
                    t_failures[trig_key].append(val)
                else:
                    t_failures[trig_key] = [val]
        return t_failures

    def receive(msg=('checkpoint_shuttle', encrypted_payload, replica_index), from_= sender):
        payload = decrypt(encrypted_payload, sender)
        ind = int(replica_index) +  1
        output('R: [checkpoint_shuttle] F: ' + getSenderId(sender) + ' T: Replica ' + getSelfId() + ' I: current history len ' + str(len(self.history)))
        sendCheckpoint(ind, payload[1], payload[0])

    def receive(msg=('checkpoint_proof', encrypted_payload, replica_index), from_= sender):
        payload = decrypt(encrypted_payload, sender)
        ind = int(replica_index) -  1
        chkpnt_len = payload[0]
        output('R: [checkpoint_proof] F: ' + getSenderId(sender) + ' T: Replica ' + getSelfId() + ' I: current history len ' + str(len(self.history)) + ' checkpoint len - ' + str(chkpnt_len))
        proof = payload[1]
        slice =  {k: self.history[k] for k in sorted(self.history.keys())[:chkpnt_len]}
        binary_slice = pickle.dumps(slice)
        slice_hash = self.HASHER(binary_slice, encoder=nacl.encoding.HexEncoder)
        if validCheckpointProof(chkpnt_len, proof, slice_hash) == False:
            output('S: [recofig] F: Replica ' + getSelfId() + ' T: olympus I: Error in checkpoint proof validation')
            sendReconfigReq()
            return

        truncateHistory(0, chkpnt_len)
        self.checkpoints.append([chkpnt_len, proof])
        self.checkpoint_complete = True
        if ind >= 0 :
            output('S: [checkpoint_proof] F: Replica ' + getSelfId() + ' T: Replica ' + str(ind) + ' I: current history len ' +  str(len(self.history)) + ' checkpoint len - ' + str(chkpnt_len))

            encrypted_checkpoint = getEncryptedMsg([chkpnt_len, proof], self.replica_public_keys[str(list_replicas[ind])])
            send(('checkpoint_proof', encrypted_checkpoint, ind), to= self.list_replicas[ind])

    def validCheckpointProof(chkpnt_len, proof, slice_hash):
        for [len, hash] in proof :
            if slice_hash != hash or len != chkpnt_len:
                output("E: [FAILL] [checkpoint proof] [Replica "+ getSelfId() + "]")
                return False
        return True

    def truncateHistory(startInd, endInd):
        keys = [k for k in sorted(self.history.keys())[startInd:endInd]]
        for k in keys:
            self.history.pop(k, None)

    def sendCheckpoint(ind, proof, chkpnt_len):
        await(len(self.history) > self.checkpoint_len)
        slice =  {k: self.history[k] for k in sorted(self.history.keys())[:chkpnt_len]}
        binary_slice = pickle.dumps(slice)
        slice_hash = self.HASHER(binary_slice, encoder=nacl.encoding.HexEncoder)
        if validCheckpointProof(chkpnt_len, proof, slice_hash) == False:
            output('S: [recofig] F: Replica ' + getSelfId() + ' T: olympus I: Error in checkpoint proof validation')
            sendReconfigReq()
            return
        proof.append([chkpnt_len, slice_hash])
        if(ind == (len(self.list_replicas))):
            truncateHistory(0, chkpnt_len)
            self.checkpoints.append([chkpnt_len, proof])
            output('S: [checkpoint_proof] F: Replica ' + getSelfId() + ' T: Replica ' + str(ind-2) + ' I: current history len ' + str(len(self.history)) + ' checkpoint len - ' + str(chkpnt_len))
            encrypted_checkpoint = getEncryptedMsg([chkpnt_len, proof], self.replica_public_keys[str(list_replicas[ind-2])])
            send(('checkpoint_proof', encrypted_checkpoint, ind-2), to= self.list_replicas[ind-2])

        else :
            output('S: [checkpoint_shuttle] F: Replica ' + getSelfId() + ' T: Replica ' + str(ind-2) + ' I: current history len ' + str(len(self.history)) + ' checkpoint len - ' + str(chkpnt_len))
            encrypted_checkpoint = getEncryptedMsg([chkpnt_len, proof], self.replica_public_keys[str(list_replicas[ind])])
            send(('checkpoint_shuttle', encrypted_checkpoint, ind), to= self.list_replicas[ind])

    def sendReconfigReq():
        ReconfigRequest = {}
        ReconfigRequest['replicaConfigSeqNo'] = currConfigSeqNo
        encrypted_msg = getEncryptedMsg(ReconfigRequest, self.oly_public_key)
        send(('reconfigure', encrypted_msg), to= olympus)

    def decrypt(encrypted_payload, sender):
        if(str(sender) in client_public_keys):
            decrypt_box = Box(self.privateKey, client_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_payload)
            payload = pickle.loads(plaintext)
        else:
            decrypt_box = Box(self.privateKey, replica_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_payload)
            payload = pickle.loads(plaintext)
        return payload

    def forwardOrderShuttle(order_shuttle, ind):
        client_id = list_clients.index(order_shuttle['client'])
        if(ind == (len(list_replicas))):

            clientResult = {}
            clientResult['seqNo'] = order_shuttle['seqNo']
            clientResult['client'] = order_shuttle['client']
            clientResult['oper'] = order_shuttle['oper']
            clientResult['result'] = order_shuttle['result']
            clientResult['result_proof'] = order_shuttle['result_proof']

            injectFailure(client_id, clientResult, 'sendRes', ind)

            cache[str(order_shuttle['client']) + ' : ' + str(order_shuttle['seqNo'])] = clientResult

            output('S: [result_message] F: Replica ' + getSelfId() + ' T: Client' + str(client_id) + ' I: client Id - ' + str(client_id) + ' seqNo - '+ str(order_shuttle['seqNo']) +' oper-' + order_shuttle['oper'])
            encrypted_msg = getEncryptedMsg(clientResult, client_public_keys[str(order_shuttle['client'])])
            send(('result_message', encrypted_msg), to= order_shuttle['client'])

            ## ind is already beyond last replica index. So subtract 2
            ind = ind - 2
            output('S: [result_shuttle] F: Replica ' + getSelfId() + ' T: Replica ' + str(ind) + ' I: client Id - ' + str(client_id) + ' seqNo - '+ str(order_shuttle['seqNo']) +' oper-' + order_shuttle['oper'])

            encrypted_result_shuttle = getEncryptedMsg(clientResult, self.replica_public_keys[str(list_replicas[ind])])
            send(('result_shuttle', encrypted_result_shuttle, str(ind)), to= list_replicas[ind])
        else :
            output('S: [execute] F: Replica ' + getSelfId() + ' T: Replica ' + str(ind) + ' I: client Id - ' + str(client_id) + ' seqNo - '+ str(order_shuttle['seqNo']) +' oper-' + order_shuttle['oper'])
            encrypted_msg = getEncryptedMsg(order_shuttle, replica_public_keys[str(list_replicas[ind])])

            send(('execute', encrypted_msg, str(ind)), to= list_replicas[ind])

    def injectFailure(client_id, dataStr, type, ind):
        if type == 'sendRes':
            if self.ch_res[client_id]:
                output('I: [INJECT FAILURE] [Replica ' + getSelfId() + '] [change result] client ' + str(client_id))
                binary_result = pickle.dumps('OK')
                result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
                dataStr['result_proof'][str(list_replicas[ind-1])][0][3] = result_hash
                self.ch_res[client_id] = False
            if self.drop_res[client_id] :
                output('I: [INJECT FAILURE] [Replica ' + getSelfId() + '] [drop result] client ' + str(client_id))
                dataStr['result_proof'].pop(str(list_replicas[0]))
                self.drop_res[client_id] = False
        if type == 'recOper' and self.ch_oper[client_id] :
            output('I: [INJECT FAILURE] [Replica ' + getSelfId() + '] [change operation] I: client ' + str(client_id) + ' order_stmt - ' + str(dataStr))
            dataStr[3] = "get('x')"
            self.ch_oper[client_id] = False


    def getSelfId():
        return str(self.list_replicas.index(self))

    def getSenderId(sender):
        if sender in self.list_replicas:
            return 'Replica ' + str(self.list_replicas.index(sender))
        elif sender in self.list_clients:
            return 'Client ' + str(self.list_clients.index(sender))
        else :
            return 'Olympus ' + str(sender)

    def getEncryptedMsg(msg, receiverPubKey):
        box = Box(self.privateKey, receiverPubKey)
        binary_msg = pickle.dumps(msg)
        encrypted_msg = box.encrypt(binary_msg)
        return encrypted_msg

    def dict_to_binary(the_dict):
        binary = pickle.dumps(the_dict)
        return binary

    def binary_to_dict(the_binary):
        d = pickle.loads(the_binary)
        return d

    def run():
        await(terminate)
        output('I: [Terminated] Replica ' + getSelfId())


def inject_ch_res(client_id, shuttle, ind):
    if self.ch_res[client_id]:
        output('I: [INJECT FAILURE] [Replica ' + getSelfId() + '] [change result] client ' + str(client_id))
        binary_result = pickle.dumps('OK')
        result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)
        shuttle['result_proof'][str(list_replicas[ind-1])][0][3] = result_hash
        self.ch_res[client_id] = False

def inject_drop_res(client_id, shuttle, ind):
    if self.drop_res[client_id] :
        output('I: [INJECT FAILURE] [Replica ' + getSelfId() + '] [drop result] client ' + str(client_id))
        shuttle['result_proof'].pop(str(list_replicas[0]))
        self.drop_res[client_id] = False

def inject_ch_oper(stmt):
    if self.ch_oper[client_id] :
        output('I: [INJECT FAILURE] [Replica ' + getSelfId() + '] [change operation] I: client ' + str(client_id) + ' order_stmt - ' + str(dataStr))
        stmt[3] = "get('x')"
        self.ch_oper[client_id] = False
def inject_trunc(wedge):
    if(self.trunc > 0):
        last_key = list(wedge['History'].items)[-1][0]
        wedge['History'].pop(last_key)
        self.trunc = 0

def inject_invalid_order_sig(signed):
    if self.invalidOrderSig :
        self.invalidOrderSig = False
        signedlist = list(signed)
        signedlist[0] = (signedlist[0] + 1) % 256
        newsigned=bytes(signedlist)
        invalid_signed = nacl.signing.SignedMessage._from_parts(signed._signature, signed._message, newsigned)
        return invalid_signed
    return signed

def inject_invalid_result_sig(signed):
    if self.invalidResultSig :
        self.invalidResultSig = False
        signedlist = list(signed)
        signedlist[0] = (signedlist[0] + 1) % 256
        newsigned=bytes(signedlist)
        invalid_signed = nacl.signing.SignedMessage._from_parts(signed._signature, signed._message, newsigned)
        return invalid_signed
    return signed

def inject_drop_checkpt_stmts(proof):
    if self.drop_chkpnts :
        self.drop_chkpnts = False
        t1 = (int(config['t']) + 1)
        if(len(proof) > t1):
            proof = proof[:-t1]
        else
            proof = []
