import sys
import pickle
from nacl.public import PrivateKey, Box
import logging

class Replica(process):
    def setup(olympus: Olympus, list_clients: list, list_replicas: list, config: set):
        self.logger = logging.getLogger(__name__)
        self.history = {}
        self.cache = {}
        self.slot_no = 0
        self.core_data = {}
        self.terminate = False
        self.isImmutable = False
        self.privateKey = "Default"
        self.client_public_keys = {}
        self.publicKey = "Default"
        self.replica_public_keys = {}
        self.m_client_req = [-1]*config['num_clients']
        self.m_fwd_req = [-1]*config['num_clients']
        self.m_shuttle = [-1]*config['num_clients']
        self.m_r_shuttle = [-1]*config['num_clients']
        self.ch_oper = [False]*config['num_clients']
        self.ch_res = [False]*config['num_clients']
        self.drop_res = [False]*config['num_clients']
        self.failures = extract_failures()


    def receive(msg=('keys', payload), from_= sender):
        print('Received all KEYS---')
        self.privateKey = payload['private_key']
        self.publicKey = payload['public_key']
        self.replica_public_keys = payload['replica_public_keys']
        self.client_public_keys = payload['client_public_keys']

    def receive(msg=('result_shuttle', payload, replica_index), from_= sender):
        ind = int(replica_index)
        output('Received the result shuttle')
        client_id = list_clients.index(payload['client'])

        check_failures('result_shuttle', client_id)

        if ch_res[client_id]:
            payload['result_proof'][ind][3] = "##THIS IS RESULT HASH of OK ##";
            ch_res[client_id] = False
        if drop_res[client_id] :
            del payload['result_proof'][0]
            drop_res[client_id] = False
        cache[str(payload['client']) + ' : ' + str(payload['seqNo']) ] = payload
        ind -= 1
        if(ind >= 0):
            send(('result_shuttle', payload, str(ind)), to= list_replicas[ind])

    def receive(msg=('test_execute', encrypted_payload, replica_index), from_= sender):
        print('Recevied test_execute')
        decrypt_box = Box(self.privateKey, self.client_public_keys[str(sender)])
        plaintext = decrypt_box.decrypt(encrypted_payload)

        payload = pickle.loads(plaintext)
        print('Test_execute: Decrypted payload is - ')
        print(payload)

    def receive(msg=('execute', encrypted_payload, replica_index), from_= sender):

        #payload = encrypted_payload ## THIS IS USED FOR TEST_EXECUTE (TESTING ENCRYPTION)

        ind = int(replica_index) + 1
        client_id = list_clients.index(payload['client'])
        if(ind == 1):
            ## HEAD case
            print('head Received request from Client for task execution..')

            decrypt_box = Box(self.privateKey, client_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_payload)
            payload = pickle.loads(plaintext)
            print('Decrypted payload at HEAD is - ')
            print(payload)

            ## Verify if this slot is not already occupied and its previous is occupied.
            if(self.slot_no not in history and ( self.slot_no == 0 or (self.slot_no - 1) in history)) :
                result = execute_actual_command(payload['oper'])
                print("Execution Result at HEAD is - " + result)
                order_shuttle = payload
                order_shuttle['type'] = "Order Shuttle"
                order_shuttle['slot_no'] = self.slot_no
                order_shuttle['result'] = result
                order_proof = []
                result_proof = []
                print('Creating order stmt...')
                order_stmt = (self.slot_no, payload['client'], payload['seqNo'], payload['oper'], );
                print('Processing Order Shuttle')

                if sender != self:
                    check_failures('client_request', client_id)

                if self.ch_oper[client_id] :
                    order_stmt['oper'] = "get('x')"
                    self.ch_oper[client_id] = False

                order_shuttle = process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result)

                print('Adding to History...')
                history[order_shuttle['slot_no']] = order_stmt

                encrypted_msg = getEncryptedMsg(order_shuttle, replica_public_keys[str(list_replicas[ind])])

                send(('execute', encrypted_msg, str(ind)), to= list_replicas[ind])
                # send(('execute', order_shuttle, str(ind)), to= list_replicas[ind])
                self.slot_no +=1
            else:
                output('invalid slot_no... or waiting for previous slot')
        elif(ind == (len(list_replicas))):

            #print('In TAIL')
            ## TAIL case

            decrypt_box = Box(self.privateKey, replica_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_payload)
            payload = pickle.loads(plaintext)
            print('Decrypted payload at TAIL is - ')
            print(payload)

            result = ""
            order_shuttle = payload
            order_stmt = ( payload['slot_no'],  payload['client'], payload['seqNo'], payload['oper']);
            if(validate_order_proof(order_shuttle["order_proof"],order_stmt)):
                result = execute_actual_command(order_shuttle['oper'])
                print("Execution Result at TAIL is - " + result)
                order_proof = order_shuttle['order_proof']
                result_proof = order_shuttle['result_proof']

                if not validate_result_proof(result_proof, result):
                    output('invalid result_proof')
                    ## Reconfig request from replica
                else :
                    check_failures('forward_request', client_id)

                    if self.ch_oper[client_id] :
                        order_stmt['oper'] = "get('x')"
                        self.ch_oper[client_id] = False
                    order_shuttle = process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result)

                    history[order_shuttle['slot_no']] = order_stmt

                    clientResult = {}
                    clientResult['seqNo'] = order_shuttle['seqNo']
                    clientResult['client'] = order_shuttle['client']
                    clientResult['oper'] = order_shuttle['oper']
                    clientResult['result'] = result
                    clientResult['result_proof'] = order_shuttle['result_proof']

                    if ch_res[client_id]:
                        clientResult['result_proof'][ind][3] = "##THIS IS RESULT HASH of OK ##";
                        ch_res[client_id] = False
                    if drop_res[client_id] :
                        del clientResult['result_proof'][0]
                        drop_res[client_id] = False

                    cache[str(order_shuttle['client']) + ' : ' + str(order_shuttle['seqNo'])] = clientResult

                    ## ind is already beyond last replica index. So subtract 2
                    ind = ind - 2
                    send(('result_shuttle', clientResult, str(ind)), to= list_replicas[ind])

                    ## Send Result to client
                    send(('execution_success', clientResult), to= payload['client'])
            else:
                output('Some error in order proof validation. Reconfigure the system...')
                ## Reconfig request from replica

        else:
            ## REST of the cases
            #print('In MIDDLE')

            decrypt_box = Box(self.privateKey, replica_public_keys[str(sender)])
            plaintext = decrypt_box.decrypt(encrypted_payload)
            payload = pickle.loads(plaintext)
            print('Decrypted payload in MIDDLE is - ')
            print(payload)

            order_shuttle = payload
            order_stmt = (payload['slot_no'], payload['client'], payload['seqNo'], payload['oper']);
            if(validate_order_proof(order_shuttle["order_proof"],order_stmt)):
                result = execute_actual_command(order_shuttle['oper'])
                print("Execution Result is - " + result)
                order_proof = order_shuttle['order_proof']
                result_proof = order_shuttle['result_proof']
                check_failures('forward_request', client_id)
                if not validate_result_proof(result_proof,result):
                    output('invalid result_proof')
                    ## Reconfig request from replica
                else :
                    if self.ch_oper[client_id] :
                        order_stmt['oper'] = "get('x')"
                        self.ch_oper[client_id] = False
                    order_shuttle = process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result)
                    history[order_shuttle['slot_no']] = order_stmt

                    encrypted_msg = getEncryptedMsg(order_shuttle, replica_public_keys[str(list_replicas[ind])])
                    send(('execute', encrypted_msg, str(ind)), to= list_replicas[ind])

                    #send(('execute', order_shuttle, str(ind)), to= list_replicas[ind])
            else:
                output('Some error in order proof validation. Reconfigure the system...')
                ## Reconfig request from replica

    def process_order_shuttle(order_shuttle, order_proof, result_proof, order_stmt, result):
        order_proof.append(order_stmt)
        order_shuttle['order_proof'] = order_proof
        result_hash = "##THIS IS RESULT HASH of " + result + " ##";
        ##result_proof.append((order_shuttle['client'], order_shuttle['seqNo'], order_shuttle['oper'], result_hash))
        result_proof.append((order_stmt[1], order_stmt[2], order_stmt[3], result_hash))
        order_shuttle['result_proof'] = result_proof
        return order_shuttle

    def validate_order_proof(order_proof,order_stmt):
        #check if received slot no is not in history and the previous slot is finished
        slot_no = int(order_stmt[0])
        if(slot_no in history or ( slot_no != 0 and (slot_no - 1) not in history)) :
            return False
        for each_order_p in order_proof:
            if(each_order_p != order_stmt):
                return False;
        return True

    def validate_result_proof(result_proof,result):
        cur_hash = "##THIS IS RESULT HASH of " + result + " ##";
        for res_stmt in result_proof:
            if res_stmt[3] != cur_hash:
                return False
        return True;

    def execute_actual_command(operation):
        output('Executing actual operation command ...' + operation)
        result = ""
        ## execute operation on current state
        splits = operation.split("'")
        if(operation[0] == 'p'):
            ind = operation.index(',')
            ind1 = len(operation) - 1
            key = operation[4:ind].strip('\'').strip()
            val = operation[ind+1 : ind1].strip('\'')
            print(key, ' => ', val)
            core_data[key] = val
            result = "OK"
        elif(operation[0] == 'g'):
            ind = operation.index('(')+1
            ind1 = len(operation) - 1
            key = operation[ind: ind1].strip('\'').strip()
            print(key)
            if(key in core_data):
                result = core_data[key]
            else:
                result = ""
        elif(operation[0] == 'a'):
            ind = operation.index(',')
            ind1 = len(operation) - 1
            key = operation[8:ind].strip('\'').strip()
            val = operation[ind+1 : ind1].strip('\'')
            if(key in core_data):
                core_data[key] = str(core_data[key]) + str(val)
                result = "OK"
            else:
                result = "fail"
            print(key, ' => ', val)
        elif(operation[0] == 's'):
            ind = operation.index(',')
            ind1 = len(operation) - 2
            key = operation[6:ind].strip('\'').strip()
            ran = operation[ind+2 : ind1]
            start_end = ran.split(':')
            print(key, ' => ', start_end)
            if(key in core_data and (int(start_end[0]) >= 0) and (int(start_end[1]) <= len(core_data[key]))):
                core_data[key] = core_data[key][int(start_end[0]):int(start_end[1])]
                result = "OK"
            else:
                result = "Fail"
        else:
            result = "fail"
        return result

    def receive(msg=('retrans', command, replica_index), from_= sender):
        output('Received retransmission...')
        cache_key = str(command['client']) + ' : ' + str(command['seqNo'])
        client_id = list_clients.index(command['client'])
        if sender == command['client']:
            check_failures('client_request', client_id)
        else :
            check_failures('forward_request', client_id)
        if(cache_key in cache):
            if ch_res[client_id]:
                clientResult['result_proof'][ind][3] = "##THIS IS RESULT HASH of OK ##";
                ch_res[client_id] = False
            if drop_res[client_id] :
                del clientResult['result_proof'][0]
                drop_res[client_id] = False

            send(('retrans_res', cache[cache_key]), to= command['client'])
        elif(self.isImmutable):
            send(('Error - Replica Immutable'), to= command['client'])
        else:
            ind = int(replica_index) + 1
            if(ind == 1):
                ## HEAD
                #check if oper in history
                foundSlot = False
                for slot in history:
                    stmt = history[slot]
                    if(stmt[1] == command['client'] and stmt[2] == command['seqNo'] and stmt[3] == command['oper']):
                        foundSlot = True
                if not foundSlot:
                    send(('execute', command, '0'), to= self.list_replicas[0])
                ## Start the replica timer for retranmission
            else:
                ## send retrans to head and wait for result.
                send(('retrans', command, '0'), to= self.list_replicas[0])
            if await(cache_key in cache):

                if ch_res[client_id]:
                    clientResult['result_proof'][ind][3] = "##THIS IS RESULT HASH of OK ##";
                    ch_res[client_id] = False
                if drop_res[client_id] :
                    del clientResult['result_proof'][0]
                    drop_res[client_id] = False
                    send(('retrans_res', cache[cache_key]), to= command['client'])
            elif timeout(5):
                    output('retrans failed, replica dint receive result shuttle')
                    ##send reconfig

    def getEncryptedMsg(msg, receiverPubKey):
        box = Box(self.privateKey, receiverPubKey)
        binary_msg = pickle.dumps(msg)
        encrypted_msg = box.encrypt(binary_msg)
        return encrypted_msg

    def dict_to_binary(the_dict):
        binary = pickle.dumps(the_dict)
        return binary

    def binary_to_dict(the_binary):
        d = pickle.loads(the_binary)
        return d

    def run():
        output('Started Replica...waiting for an operations...')
        await(terminate)

    def check_failures(type, client_id):
            if type == 'client_request':
                self.m_client_req[client_id] += 1
                failure_key =  'client_request(' + str(client_id) + ',' + str(self.m_client_req[client_id]) + ')'
            elif type == 'result_shuttle':
                self.m_r_shuttle[client_id] += 1
                failure_key =  type + '(' + str(client_id) + ',' + str(self.m_r_shuttle[client_id]) + ')'
            elif type == 'forward_request':
                self.m_fwd_req[client_id] += 1
                failure_key =  type + '(' + str(client_id) + ',' + str(self.m_fwd_req[client_id]) + ')'
            elif type == 'shuttle':
                self.m_shuttle[client_id] += 1
                failure_key =  type + '(' + str(client_id) + ',' + str(self.m_shuttle[client_id]) + ')'

        if failure_key in failures :
            failure = failures[failure_key]
            if failure == 'change_operation()':
                self.ch_oper[client_id] = True
            elif failure == 'change_result()':
                self.ch_res[client_id] = True
            elif failure == 'drop_result_stmt()':
                self.drop_res[client_id] = True

    def extract_failures() :
        str_fail = config['failures[0,' + str(list_replicas.index(self)) + ']']
        failures = {}
        splits = str_fail.split(';')
        for trig_fail in splits:
            trig_fail = trig_fail.strip()
            ind = trig_fail.index(')') + 1
            failures[trig_fail[0:ind] = trig_fail[ind+1 : len(trig_fail)].split()
        return failures

