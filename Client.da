import sys
import pickle
import nacl
import nacl.utils
from nacl.public import PrivateKey, Box
import logging

class Client(process):
    def setup(olympus: Olympus, sys_config: set):
        self.logger = logging.getLogger(__name__)
        self.successFlag = False
        self.resultList = []
        self.seqNo = -1
        self.foundResponse = False
        self.responsesCount = 0
        self.invalidResponses = 0
        self.curr_config = {}
        self.HASHER = nacl.hash.sha256

    def receive(msg=('cur_conf', config), from_= olympus):
        output("Current Configurations received by client from olympus - " + str(olympus))
        self.curr_config = config
        successFlag = True

    def receive(msg=('execution_success', encrypted_result), from_= sender):
        output("Execution result recevied by client from tail replica - " + str(sender))
        decrypt_box = Box(curr_config['client_private_key'], curr_config['replica_public_keys'][str(sender)])
        plaintext = decrypt_box.decrypt(encrypted_result)
        result = pickle.loads(plaintext)

        if self.seqNo == int(result['seqNo']) and result['client'] == self:
            output('Received result from replica -', result)
            if is_valid_response(result):
                resultList.append(result['result']);
                successFlag = True
            else:
                output('ask for reconfig...received invalid result');

    def receive(msg=('retrans_res', encrypted_result), from_= sender):
        decrypt_box = Box(curr_config['client_private_key'], curr_config['replica_public_keys'][str(sender)])
        plaintext = decrypt_box.decrypt(encrypted_result)
        result = pickle.loads(plaintext)
        print('Decrypted payload at client for retrans is - ')
        print(result)

        output('retrans res sender: ', sender)
        if self.seqNo == int(result['seqNo']) :
            if not foundResponse and responsesCount != self.sys_config['num_replicas'] and invalidResponses <= self.sys_config['failures_handled'] + 1:
                responsesCount += 1;
                if is_valid_response(result) :
                    resultList.append(result['result'])
                    foundResponse = True
                else :
                    invalidResponses += 1;

    def receive(msg=(('Error - Replica Immutable')), from_= sender):
        ## validate with encription if valid sender has send this error msg
        ## if so retrive latest configuration and try again
        output('Recevied Error - Replica Immutable from - ' + str(sender))

    def getEncryptedMsg(msg, receiverPubKey):
        box = Box(curr_config['client_private_key'], receiverPubKey)
        binary_msg = pickle.dumps(msg)
        encrypted_msg = box.encrypt(binary_msg)
        return encrypted_msg

    def execute_operation():
        #print("Head replica - " + str(curr_config['head_replica']))
        #print("Head replica from list - " + str(self.curr_config['replicas'][0]))

        operations = sys_config['workload'][str(self)]
        output('sending operations.....')
        output(operations)
        for oper in operations:
            seqNo += 1;
            successFlag = False;
            msg = {'seqNo': self.seqNo, 'oper': oper, 'client': self}
            #msg = {'seqNo': self.seqNo, 'oper': oper, 'client': str(self)}
            encrypted_msg = getEncryptedMsg(msg, curr_config['replica_public_keys'][str(curr_config['head_replica'])])

            send(('execute', encrypted_msg, 0), to= self.curr_config['head_replica'])
            #send(('execute', msg, 0), to= self.curr_config['head_replica'])
            if await(successFlag):
                output('Received successful result...')
                output(resultList[self.seqNo]);
            elif timeout(2):
                output('Timeout...Executing retransmission...')
                execute_retransmission(msg);
                await(foundResponse)
                output(resultList[self.seqNo]);

    def fetch_config():
        # start timer
        output('Fetching current configuration request to Olympus')
        send(('current_configuration'), to= olympus)

    def is_valid_response(res):
        no_of_matches = 0
        binary_result = pickle.dumps(res['result'])
        result_hash = self.HASHER(binary_result, encoder=nacl.encoding.HexEncoder)

        first_result_proof = res['result_proof'][0]
        for i in range(0, len(res['result_proof'])):
            if((result_hash == res['result_proof'][i][3]) && (res['result_proof'][i][2] == sys_config['workload'][str(self)][seqNo])):
                no_of_matches += 1
            if(no_of_matches == (int(sys_config['failures_handled']) + 1)):
                output("T+1 result hashes matched.")
                return True
        return False

    def abort():
        output('abort...!')
    def success():
        output('success..!')

    def execute_retransmission(msg):
        output('Executing retransmission...')
        self.foundResponse = False
        self.responsesCount = 0
        self.invalidResponses = 0
        for i in range(0, len(curr_config['replicas'])):
            encrypted_msg = getEncryptedMsg(msg, curr_config['replica_public_keys'][str(curr_config['replicas'][i])])
            send(('retrans', encrypted_msg, str(i)), to= curr_config['replicas'][i])
        #for replica in self.curr_config['replicas']:
        #    encrypted_msg = getEncryptedMsg(msg, curr_config['replica_public_keys'][str(replica)])
        #    send(('retrans', encrypted_msg, '0'), to= replica)

    def test_encryption():
        msg = {'seqNo': self.seqNo, 'oper': "put('luke', 'luke skywalker')", 'client': self}
        encrypted_msg = getEncryptedMsg(msg, curr_config['replica_public_keys'][str(curr_config['head_replica'])])
        send(('test_execute', encrypted_msg, 0), to= self.curr_config['head_replica']);

    def run():
        output("SANKET!!!")
        fetch_config();
        await(successFlag)
        #test_encryption()
        execute_operation()

        #msg = {'seqNo': (self.seqNo + 1), 'oper': "put('idiot', 'assface')", 'client': self}
        #execute_retransmission(msg)

        output('Terminating...');
        #if await(successFlag):
        #    output('terminating...');
        #elif timeout(2):
        #    execute_retransmission();
        #    output('Executed retransmission...')
        #    if await(successFlag):
        #        output('retransmit worked...so did timeout...terminating...', self.ope);
        #    elif timeout(5):
        #        output('retransmit failed...but Timeout worked');


    def dict_to_binary(the_dict):
        binary = pickle.dumps(the_dict)
        return binary

    def binary_to_dict(the_binary):
        d = pickle.loads(the_binary)
        return d